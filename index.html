<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>Happy Birthday</title>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" href="./css/bootstrap.min.css">
    <link rel="stylesheet" href="./css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="./css/mystyle.css"/>
    <link rel="shortcut icon" href="./img/sat.png"/>
    <script type="text/javascript" src="./js/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="./js/lib_sylvester.js"></script>
    <script type="text/javascript" src="./js/lib_glUtils.js"></script>
    <script id="shader-fs" type="x-shader/x-fragment">
      precision highp float;
      varying float vLightWeighting;
      varying vec2 vTextureCoord;
      uniform sampler2D uSampler;
      void main(void) {
        gl_FragColor = vLightWeighting * texture2D(uSampler, vTextureCoord);
        gl_FragColor[3] = 1.0;
      }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexNormal,
      aVertexPosition;
      attribute vec2 aTextureCoord;
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform int render;
      varying vec2 vTextureCoord;
      varying float vLightWeighting;
      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
        if (render == 1 && aVertexNormal[0] != 2.0) {
          vLightWeighting = (1.0 - smoothstep(2.0, 20.0, length(gl_Position)) * 0.85);
          return;
        } else {
          vLightWeighting = 1.0;
          return;
        }
      }
    </script>
    
    <script type='text/javascript'>
      $(document).ready(main);
      var CANVAS, GL, MAPS, WEBGL = null, SHADER_PROGRAM, CAMERA, MAZE, TIMER;
      var border = 0.001, imgWs, imgHs;
      function main() {
        CANVAS = document.getElementById("canvas");
        try {
          GL = CANVAS.getContext("experimental-webgl");
        } catch(e) {}
        if (!GL) {
          document.getElementById('info').style.display = 'block';
          return;
        }
        MAPS = initMaps();
        document.getElementById('bgmusic').addEventListener('ended', function() {this.currentTime = 0;}, false);
        document.getElementById('birthmusic').addEventListener('ended', function() {this.currentTime = 0;}, false);
        loadLevel();
      }
      function initMaps() {
        var maps = new Array();
        var lvl = 0;
        maps[lvl] = [ [0, 0, 1, 1, 1, 1, 1, 1],
                      [1, 0, 0, 1, 0, 0, 0, 1],
                      [1, 0, 0, 1, 0, 1, 0, 0],
                      [1, 1, 1, 2, 0, 1, 1, 1],
                      [1, 0, 0, 1, 0, 0, 0, 1],
                      [1, 1, 0, 1, 1, 1, 1, 1] ];
        maps[lvl].params = [8, 6, 0, 1, 5, 2];
        lvl++;
        maps[lvl] = [ [0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0],
                      [0,1,1,1,1,1,1,2,1,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,2,0,0,0,0,0,0,0,0],
                      [0,1,1,1,1,1,1,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0] ];
        maps[lvl].params = [32, 16, 1, 1, 21, 0];
        maps[lvl][13][13] = 60523;
        maps[lvl][9][29] = 49463;
        lvl++;
        maps[lvl] = [ [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
                      [0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
                      [0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
                      [0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
                      [0,0,1,1,1,1,1,2,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,1,2,1,1,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0],
                      [0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,1,2,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,1,1,1,2,1,1,1,1,1,1,1,0],
                      [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,1,1,1,1,1,2,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0],
                      [0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0],
                      [1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0],
                      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0] ];
        maps[lvl].params = [64, 16, 3, 1, 58, 0];
        maps[lvl][14][14] = 55503;
        maps[lvl][0][27] = 58503;
        maps[lvl][3][44] = 55543;
        maps[lvl][6][61] = 48453;
        lvl++;
        maps.LEVEL_MAX = lvl + 1;
        maps.LEVEL = 0;
        return maps;
      }
      
      function Camera() {
        this.click = 0;
        this.ACL_THETA = 0;
        this.OLD_MOVE_X = 0;
        this.jump = 0;
        this.jump_i = 0;
        this.jump_t = 0;
        this.jump_xx = 0;
        this.jump_yy = 0;
        this.jump_zz = 0;
        this.jump_x = 0;
        this.jump_y = 0;
        this.jump_z = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.CAM_THETA = 0;
        this.CAM_PHI = 0;
        this.jumping = function() {
          if (this.jump == 0) {
            this.jump = 1;
          }
        }
      }
      function binding() {
        document.onmousedown = function(e) {
          e.preventDefault();
          if (e.button == 0) CAMERA.click = 0.3;
          if (e.button == 2) CAMERA.jumping();
        }
        document.onmouseup = function(e) {
          if (e.button == 0) CAMERA.click = 0;
        }
        document.onmousemove = function(e) {
          CAMERA.ACL_THETA = 0;
          if (e.clientX < CANVAS.width * 0.2) CAMERA.ACL_THETA = (e.clientX - CANVAS.width * 0.2) / CANVAS.width * 0.1;
          if (e.clientX > CANVAS.width * 0.8) CAMERA.ACL_THETA = (e.clientX - CANVAS.width * 0.8) / CANVAS.width * 0.1;
          CAMERA.CAM_THETA += (e.clientX - CAMERA.OLD_MOVE_X) / CANVAS.width * 2;
          CAMERA.CAM_PHI = (e.clientY - 0.5 * CANVAS.height) / CANVAS.height * Math.PI;
          CAMERA.OLD_MOVE_X = e.clientX;
        }
        document.oncontextmenu = new Function("return false");
        document.onkeydown = function(e) {
          switch (e.keyCode) {
          case 37:
          case 65:
          case 97:
            CAMERA.ACL_THETA = -0.02;
            break;
          case 39:
          case 68:
          case 100:
            CAMERA.ACL_THETA = 0.02;
            break;
          case 38:
          case 87:
          case 119:
            CAMERA.click = 0.3;
            break;
          case 40:
          case 83:
          case 115:
            CAMERA.click = -0.3;
            break;
          case 32:
            CAMERA.jumping();
            break;
          }
        }
        document.onkeyup = function(e) {
          switch (e.keyCode) {
          case 37:
          case 65:
          case 97:
          case 39:
          case 68:
          case 100:
            CAMERA.ACL_THETA = 0;
            break;
          case 38:
          case 87:
          case 119:
          case 40:
          case 83:
          case 115:
            CAMERA.click = 0;
            break;
          }
        }
        window.onresize = function() {
          CANVAS.width = window.innerWidth;
          CANVAS.height = window.innerHeight;
          GL.viewportWidth = CANVAS.width;
          GL.viewportHeight = CANVAS.height;
          GL.viewportX = CANVAS.offsetLeft;
          GL.viewportY = CANVAS.offsetTop;
          GL.viewport(0.0, 0.0, GL.viewportWidth, GL.viewportHeight);
          lib_matrix_perspective(72, GL.viewportWidth / GL.viewportHeight, 0.05, 60.0);
        }
        window.onblur = function displayOff(event) {
          WEBGL.scene.DISPLAYED = false;
        }
        window.onfocus = function displayOn(event) {
          WEBGL.scene.DISPLAYED = true;
        }
      }
      
      var candleMap = [ [0, 0, 0, 0, 1],
                        [1, 1, 1, 0, 1],
                        [0, 0, 1, 0, 1],
                        [0, 0, 1, 0, 1],
                        [1, 1, 1, 0, 1],
                        [1, 0, 0, 0, 1],
                        [1, 0, 0, 0, 1],
                        [1, 1, 1, 0, 1] ];
      
      var loaded = 0;
      function finishLoading(t) {
        loaded += t;
      }
      
      function loadLevel() {
        if (MAPS.LEVEL < MAPS.LEVEL_MAX - 1) {
          if (MAPS.LEVEL == 0) document.getElementById('info0').style.display = 'block';
          if (MAPS.LEVEL == 1) document.getElementById('info1').style.display = 'block';
          if (MAPS.LEVEL == 2) document.getElementById('info2').style.display = 'block';
          document.getElementById('startButton').innerHTML = "loading...";
          document.getElementById('startButton').style.display = 'block';
          if (WEBGL == null) {
            WEBGL = new Object();
            WEBGL.shaders = new Shaders();
            WEBGL.scene = new Scene();
            CAMERA = new Camera();
            binding();
            window.onresize();
          }
          if (MAPS.LEVEL == 0) {imgWs = 4;imgHs = 4;}
          if (MAPS.LEVEL >= 1) {imgWs = 4;imgHs = 4;}
          MAZE = new Maze(MAPS[MAPS.LEVEL]);
          MAZE.load();
          var bg = new Background(8 + 0.5 * Math.sqrt(MAZE.width * MAZE.width + MAZE.height * MAZE.height), MAZE.width * 0.5, MAZE.height * 0.5);
          var wall, sky;
          if (MAPS.LEVEL == 0) {
            wall = new Obj('img/level_0.jpg', MAZE.vertexPositions, MAZE.vertexNormals, MAZE.vertexTextureCoords, MAZE.vertexIndices, 1);
            sky = new Obj("img/bg.jpg", bg.vertexPositions, bg.vertexNormals, bg.vertexTextureCoords, bg.vertexIndices, 2);
          }
          if (MAPS.LEVEL == 1) {
            wall = new Obj('img/level_1.jpg', MAZE.vertexPositions, MAZE.vertexNormals, MAZE.vertexTextureCoords, MAZE.vertexIndices, 1);
            sky = new Obj("img/bg.jpg", bg.vertexPositions, bg.vertexNormals, bg.vertexTextureCoords, bg.vertexIndices, 2);
          }
          if (MAPS.LEVEL == 2) {
            wall = new Obj('img/level_2.jpg', MAZE.vertexPositions, MAZE.vertexNormals, MAZE.vertexTextureCoords, MAZE.vertexIndices, 1);
            sky = new Obj("img/bg.jpg", bg.vertexPositions, bg.vertexNormals, bg.vertexTextureCoords, bg.vertexIndices, 2);
          }
          WEBGL.scene.empty();
          WEBGL.scene.addObject(wall);
          WEBGL.scene.addObject(sky);
          WEBGL.scene.load();
          CAMERA.x = MAZE.startX + 0.5;
          CAMERA.y = MAZE.startY + 0.5;
          CAMERA.z = 0.5;
        } else if (MAPS.LEVEL == MAPS.LEVEL_MAX - 1) {
          document.getElementById('info3').style.display = 'block';
          document.getElementById('startButton').innerHTML = "loading...";
          document.getElementById('startButton').style.display = 'block';
        } else {
          document.getElementById('info4').style.display = 'block';
        }
        function check() {
          if (MAPS.LEVEL < MAPS.LEVEL_MAX - 1) {
            if (WEBGL.scene.checkLoaded()) {
              clearInterval(TIMER);
              if (MAPS.LEVEL == 0) {
                document.getElementById('startButton').innerHTML="<input type='button' class='btn btn-primary' value='GO' onClick='startDrawing()'/>";
              } else {
                document.getElementById('startButton').innerHTML="<input type='button' class='btn btn-primary' value='GO' onClick='startDrawing()'/>";
              }
            }
          } else {
            if (loaded == 15) {
              clearInterval(TIMER);
              document.getElementById('startButton').innerHTML="<input type='button' class='btn btn-primary' value='GO' onClick='startDrawing()'/>";
            }
          }
        }
        TIMER = setInterval(check, 100);
      }
      
      var left = 540, up = 250, rowlen = 20, collen = 40, row = -1, col = -1;
      var candleH = 80, candleW = 30;
      
      function myBinding() {
        document.onmousedown = function(e) {
          e.preventDefault();
        }
        document.onmouseup = function(e) {
          if (e.button == 0 || e.button == 2) {
            if (row != -1) {
              if (candleMap[row][col] != 0) candleMap[row][col] = 3 - candleMap[row][col];
              if (candleMap[row][col+1] != 0) candleMap[row][col+1] = 3 - candleMap[row][col+1];
              if (candleMap[row+1][col] != 0) candleMap[row+1][col] = 3 - candleMap[row+1][col];
              if (candleMap[row+1][col+1] != 0) candleMap[row+1][col+1] = 3 - candleMap[row+1][col+1];
            }
          }
        }
        document.onmousemove = function(e) {
          var x = e.offsetX - collen / 2, y = e.offsetY - rowlen / 2 - 5;
          row = parseInt((y - up) / rowlen);
          if (y < up || x + 7 * row < left) {
            row = -1;
            col = -1;
            return;
          }
          col = parseInt((x - left + 7 * row) / collen);
          if (row >= candleMap.length - 1 || col >= candleMap[0].length - 1) {
            row = -1;
            col = -1;
          }
        }
        document.oncontextmenu = new Function("return false");
      }
      
      function myDrawing() {
        var drawing = document.getElementById("mycanvas");
        var context = drawing.getContext("2d");
        var cake = document.getElementById("cake");
        context.drawImage(cake, 0, 0, 1000, 600);
        var candle1 = document.getElementById("candle1");
        var candle2 = document.getElementById("candle2");
        var flag = true;
        for (var i=0;i<candleMap.length;i++) {
          for (var j=0;j<candleMap[i].length;j++) {
            if (candleMap[i][j] == 1) {
              context.drawImage(candle1, left + collen * j - 7 * i, up + rowlen * i, candleW, candleH);
              flag = false;
            } else if (candleMap[i][j] == 2) {
              context.drawImage(candle2, left + collen * j - 7 * i, up + rowlen * i, candleW, candleH);
            }
          }
        }
        var square = document.getElementById("square");
        if (row != -1) {
          context.drawImage(square, left + collen * col - 7 * row - 5, up + rowlen * row, candleW + collen, rowlen * 2.6);
        }
        if (flag) {
          finishDrawing();
        }
      }
      
      function startDrawing() {
        document.getElementById('info0').style.display = 'none';
        document.getElementById('info1').style.display = 'none';
        document.getElementById('info2').style.display = 'none';
        document.getElementById('info3').style.display = 'none';
        document.getElementById('startButton').style.display = 'none';
        if (MAPS.LEVEL < MAPS.LEVEL_MAX - 1) {
          document.getElementById('bgmusic').play();
          document.getElementById('canvas').style.display = 'block';
          TIMER = setInterval('WEBGL.scene.draw()', 25);
        } else {
          document.getElementById('birthmusic').play();
          document.getElementById('mycanvas').style.display = 'block';
          myBinding();
          TIMER = setInterval(myDrawing, 25);
        }
      }
      function finishDrawing() {
        document.getElementById('bgmusic').pause();
        document.getElementById('birthmusic').pause();
        document.getElementById('canvas').style.display = 'none';
        document.getElementById('mycanvas').style.display = 'none';
        clearInterval(TIMER);
        MAPS.LEVEL++;
        loadLevel();
      }
      function nextFrame() {
        function checkPosition(caseX, caseY, X, Y) {
          if (X < 0.2 && (caseX == 0 || MAZE.map[caseY][caseX-1] == 0)) return false;
          if (X < 0.2 && Y < 0.2 && (caseX == 0 || caseY == 0 || MAZE.map[caseY-1][caseX-1] == 0)) return false;
          if (X < 0.2 && Y > 0.8 && (caseX == 0 || caseY == MAZE.height - 1 || MAZE.map[caseY+1][caseX-1] == 0)) return false;
          if (Y < 0.2 && (caseY == 0 || MAZE.map[caseY-1][caseX] == 0)) return false;
          if (Y > 0.8 && (caseY == MAZE.height - 1 || MAZE.map[caseY+1][caseX] == 0)) return false;
          if (X > 0.8 && (caseX == MAZE.width - 1 || MAZE.map[caseY][caseX+1] == 0)) return false;
          if (X > 0.8 && Y < 0.2 && (caseX == MAZE.width - 1 || caseY == 0 || MAZE.map[caseY-1][caseX+1] == 0)) return false;
          if (X > 0.8 && Y > 0.8 && (caseX == MAZE.width - 1 || caseY == MAZE.height - 1|| MAZE.map[caseY+1][caseX+1] == 0)) return false;
          return true;
        }
        MAZE.caseX = Math.floor(CAMERA.x);
        MAZE.caseY = Math.floor(CAMERA.y);
        if (CAMERA.click != 0 && CAMERA.jump == 0) {
          if (MAZE.caseX == MAZE.endX && MAZE.caseY == MAZE.endY) {
            finishDrawing();
            return true;
          }
          var AV_X = Math.sin(CAMERA.CAM_THETA) * 0.1 * CAMERA.click;
          var AV_Y = - Math.cos(CAMERA.CAM_THETA) * 0.1 * CAMERA.click;
          if (Math.abs(AV_X) >= Math.abs(AV_Y)) {
            if (checkPosition(MAZE.caseX, MAZE.caseY, CAMERA.x - MAZE.caseX + AV_X, CAMERA.y - MAZE.caseY)) CAMERA.x += AV_X;
            if (checkPosition(MAZE.caseX, MAZE.caseY, CAMERA.x - MAZE.caseX, CAMERA.y - MAZE.caseY + AV_Y)) CAMERA.y += AV_Y;
          } else {
            if (checkPosition(MAZE.caseX, MAZE.caseY, CAMERA.x - MAZE.caseX, CAMERA.y - MAZE.caseY + AV_Y)) CAMERA.y += AV_Y;
            if (checkPosition(MAZE.caseX, MAZE.caseY, CAMERA.x - MAZE.caseX + AV_X, CAMERA.y - MAZE.caseY)) CAMERA.x += AV_X;
          }
        } else if (CAMERA.jump > 0) {
          if (CAMERA.jump == 1) {
            CAMERA.jump = 2;
            CAMERA.jump_i = 0;
            if (MAZE.map[MAZE.caseY][MAZE.caseX] == 1) {
              CAMERA.jump_t = 40;
              CAMERA.jump_zz = 2;
              CAMERA.jump_xx = 0;
              CAMERA.jump_yy = 0;
            }
            if (MAZE.map[MAZE.caseY][MAZE.caseX] == 2) {
              if (MAPS.LEVEL == 0) CAMERA.jump_t = 80;
              else CAMERA.jump_t = 140;
              CAMERA.jump_zz = 4;
              CAMERA.jump_xx = 0;
              CAMERA.jump_yy = 0;
            }
            if (MAZE.map[MAZE.caseY][MAZE.caseX] > 2) {
              CAMERA.jump_t = 140;
              CAMERA.jump_zz = 4;
              CAMERA.jump_xx = MAZE.caseX + 0.5 + Math.floor(MAZE.map[MAZE.caseY][MAZE.caseX] / 1000) - 50 - CAMERA.x;
              CAMERA.jump_yy = MAZE.caseY + 0.5 + Math.floor(MAZE.map[MAZE.caseY][MAZE.caseX] / 10 % 100) - 50 - CAMERA.y;
            }
          }
          CAMERA.jump_i += 1;
          CAMERA.jump_x = CAMERA.jump_xx * CAMERA.jump_i / (CAMERA.jump_t * 2);
          CAMERA.jump_y = CAMERA.jump_yy * CAMERA.jump_i / (CAMERA.jump_t * 2);
          CAMERA.jump_z = 6e-4 * ((CAMERA.jump_t) * (CAMERA.jump_t) - (CAMERA.jump_i - CAMERA.jump_t) * (CAMERA.jump_i - CAMERA.jump_t));
          if (CAMERA.jump_i > CAMERA.jump_t * 2 + 0.5) {
            CAMERA.jump = 0;
            CAMERA.x += CAMERA.jump_x;
            CAMERA.y += CAMERA.jump_y;
            CAMERA.jump_x = 0;
            CAMERA.jump_y = 0;
            CAMERA.jump_z = 0;
          }
        }
        CAMERA.CAM_THETA += CAMERA.ACL_THETA;
        return false;
      }
      var Shaders = function() {
        function getShader(id) {
          var shaderScript = document.getElementById(id);
          if (!shaderScript) return null;
          var str = "";
          var k = shaderScript.firstChild;
          while (k) {
            if (k.nodeType == 3) {
              str += k.textContent;
            }
            k = k.nextSibling;
          }
          var shader;
          if (shaderScript.type == "x-shader/x-fragment") shader = GL.createShader(GL.FRAGMENT_SHADER);
          else if (shaderScript.type == "x-shader/x-vertex") shader = GL.createShader(GL.VERTEX_SHADER);
          else return null;
          GL.shaderSource(shader, str);
          GL.compileShader(shader);
          if (!GL.getShaderParameter(shader, GL.COMPILE_STATUS)) {
            return null;
          }
          return shader;
        }
        this.fragmentShader = getShader("shader-fs");
        this.vertexShader = getShader("shader-vs");
        SHADER_PROGRAM = GL.createProgram();
        GL.attachShader(SHADER_PROGRAM, this.vertexShader);
        GL.attachShader(SHADER_PROGRAM, this.fragmentShader);
        GL.linkProgram(SHADER_PROGRAM);
        GL.getProgramParameter(SHADER_PROGRAM, GL.LINK_STATUS);
        GL.useProgram(SHADER_PROGRAM);
        SHADER_PROGRAM.vertexPositionAttribute = GL.getAttribLocation(SHADER_PROGRAM, "aVertexPosition");
        GL.enableVertexAttribArray(SHADER_PROGRAM.vertexPositionAttribute);
        SHADER_PROGRAM.textureCoordAttribute = GL.getAttribLocation(SHADER_PROGRAM, "aTextureCoord");
        GL.enableVertexAttribArray(SHADER_PROGRAM.textureCoordAttribute);
        SHADER_PROGRAM.vertexNormalAttribute = GL.getAttribLocation(SHADER_PROGRAM, "aVertexNormal");
        GL.enableVertexAttribArray(SHADER_PROGRAM.vertexNormalAttribute);
        SHADER_PROGRAM.render = GL.getUniformLocation(SHADER_PROGRAM, "render");
        SHADER_PROGRAM.pMatrixUniform = GL.getUniformLocation(SHADER_PROGRAM, "uPMatrix");
        SHADER_PROGRAM.mvMatrixUniform = GL.getUniformLocation(SHADER_PROGRAM, "uMVMatrix");
        SHADER_PROGRAM.samplerUniform = GL.getUniformLocation(SHADER_PROGRAM, "uSampler");
      }
      var Scene = function() {
        this.objects = new Array();
        this.DISPLAYED = true;
        this.draw = function() {
          if (this.DISPLAYED) {
            if (nextFrame()) {
              return;
            }
            GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
            lib_matrix_loadIdentity();
            lib_matrix_mvRotateYFast(CAMERA.CAM_PHI);
            lib_matrix_mvRotateXFast(CAMERA.CAM_THETA);
            lib_matrix_mvTranslate([ - CAMERA.x - CAMERA.jump_x, - CAMERA.z - CAMERA.jump_z, - CAMERA.y - CAMERA.jump_y]);
            lib_matrix_setMatrixUniforms();
            for (i in this.objects) {
              this.objects[i].draw();
            }
            GL.flush();
          }
        }
        this.load = function() {
          GL.clearDepth(1.0);
          GL.enable(GL.DEPTH_TEST);
          GL.depthFunc(GL.LEQUAL);
          lib_matrix_perspective(72, GL.viewportWidth / GL.viewportHeight, 0.05, 150.0);
          GL.clearColor(0.0, 0.0, 0.0, 1.0);
          lib_matrix_loadIdentity();
          for (i in this.objects) {
            this.objects[i].load();
          }
        }
        this.addObject = function(object) {
          this.objects.push(object);
        }
        this.empty = function() {
          this.objects = new Array();
        }
        this.checkLoaded = function() {
          for (i in this.objects) {
            if (!(this.objects[i].texture.image.complete)) return false;
          }
          return true;
        }
      }
      var Maze = function(map) {
        this.startX = map.params[2];
        this.startY = map.params[3];
        this.endX = map.params[4];
        this.endY = map.params[5];
        this.height = map.params[1];
        this.width = map.params[0];
        this.map = map;
        this.vertexPositions = new Array();
        this.vertexNormals = new Array();
        this.vertexIndices = new Array();
        this.vertexTextureCoords = new Array();
        this.nIndices = 0;
        this.pushTexture = function(imgN, type) {
          var yImg = Math.floor(imgN / imgWs);
          var xImg = Math.floor(imgN % imgWs);
          var xMin = xImg / imgWs + border;
          var xMax = (xImg + 1) / imgWs - border;
          var yMin = 1 - yImg / imgHs - border;
          var yMax = 1 - (yImg + 1) / imgHs + border;
          if (type == 1) this.vertexTextureCoords.push(xMin, yMax, xMin, yMin, xMax, yMin, xMax, yMax);
          if (type == 2) this.vertexTextureCoords.push(xMax, yMin, xMin, yMin, xMin, yMax, xMax, yMax);
          if (type == 3) this.vertexTextureCoords.push(xMin, yMin, xMax, yMin, xMax, yMax, xMin, yMax);
          if (type == 4) this.vertexTextureCoords.push(xMin, yMin, xMax, yMin, xMax, yMax, xMin, yMax);
          if (type == 5) this.vertexTextureCoords.push(xMax, yMin, xMin, yMin, xMin, yMax, xMax, yMax);
          if (type == 6) this.vertexTextureCoords.push(xMax, yMin, xMin, yMin, xMin, yMax, xMax, yMax);
          if (type == 7) this.vertexTextureCoords.push(xMin, yMin, xMin, yMax, xMax, yMax, xMax, yMin);
        }
        this.addWall = function(xStart, yStart, xStop, yStop) {
          this.vertexPositions.push(xStart, 0, yStart, xStart, 1, yStart, xStop, 1, yStop, xStop, 0, yStop);
          var xNormal = yStop - yStart;
          var yNormal = xStop - xStart;
          this.vertexNormals.push(xNormal, yNormal, 0, xNormal, yNormal, 0, xNormal, yNormal, 0, xNormal, yNormal, 0);
          var imgN = Math.floor(Math.random() * (imgWs * imgWs - 6)) + 6;
          this.pushTexture(imgN, 1);
          this.addQuad();
        }
        this.createWalls = function() {
          for (var i = 0; i < this.height; i++) {
            for (var j = 0; j < this.width; j++) {
              if (this.map[i][j] > 0) {
                if (j == 0 || this.map[i][j - 1] == 0) {
                  this.addWall(j, i + 1, j, i);
                }
                if (j == this.width - 1 || this.map[i][j + 1] == 0) {
                  this.addWall(j + 1, i, j + 1, i + 1);
                }
                if (i == 0 || this.map[i - 1][j] == 0) {
                  this.addWall(j, i, j + 1, i);
                }
                if (i == this.height - 1 || this.map[i + 1][j] == 0) {
                  this.addWall(j + 1, i + 1, j, i + 1);
                }
                if (this.map[i][j] == 1) this.pushTexture(3, 1);
                if (this.map[i][j] == 2) this.pushTexture(4, 1);
                if (this.map[i][j] > 2) this.pushTexture(5, 1);
                this.vertexNormals.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);
                this.vertexPositions.push(j, 0, i, j + 1, 0, i, j + 1, 0, i + 1, j, 0, i + 1);
                this.addQuad();
              } else {
                this.pushTexture(2, 2);
                this.vertexNormals.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);
                this.vertexPositions.push(j + 1, 1, i + 1, j + 1, 1, i, j, 1, i, j, 1, i + 1);
                this.addQuad();
              }
            }
          }
        }
        this.addPoteau = function(x, y, type) {
          var poteauW, poteauH, pannelW;
          poteauH = 4;
          poteauW = 0.2;
          pannelW = 2;
          var imgN;
          if (type == "start") imgN = 0;
          if (type == "end") imgN = 1;
          var pw2 = 0.5 * pannelW;
          this.vertexPositions.push(x - pw2, poteauH + pannelW, y - pw2, x + pw2, poteauH + pannelW, y - pw2, x + pw2, poteauH, y - pw2, x - pw2, poteauH, y - pw2);
          this.vertexNormals.push(2, 0, -1, 2, 0, -1, 2, 0, -1, 2, 0, -1);
          this.pushTexture(imgN, 2);
          this.addQuad();
          this.vertexPositions.push(x - pw2, poteauH + pannelW, y + pw2, x + pw2, poteauH + pannelW, y + pw2, x + pw2, poteauH, y + pw2, x - pw2, poteauH, y + pw2);
          this.vertexNormals.push(2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1);
          this.pushTexture(imgN, 3);
          this.addQuad();
          this.vertexPositions.push(x - pw2, poteauH + pannelW, y - pw2, x - pw2, poteauH + pannelW, y + pw2, x - pw2, poteauH, y + pw2, x - pw2, poteauH, y - pw2);
          this.vertexNormals.push(2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0);
          this.pushTexture(imgN, 4);
          this.addQuad();
          this.vertexPositions.push(x + pw2, poteauH + pannelW, y - pw2, x + pw2, poteauH + pannelW, y + pw2, x + pw2, poteauH, y + pw2, x + pw2, poteauH, y - pw2);
          this.vertexNormals.push(2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0);
          this.pushTexture(imgN, 5);
          this.addQuad();
          this.vertexPositions.push(x + pw2, poteauH + pannelW, y + pw2, x - pw2, poteauH + pannelW, y + pw2, x - pw2, poteauH + pannelW, y - pw2, x + pw2, poteauH + pannelW, y - pw2);
          this.vertexNormals.push(0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0);
          this.pushTexture(2, 6);
          this.addQuad();
          this.vertexPositions.push(x + pw2, poteauH, y + pw2, x - pw2, poteauH, y + pw2, x - pw2, poteauH, y - pw2, x + pw2, poteauH, y - pw2);
          this.vertexNormals.push(0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0);
          this.pushTexture(2, 6);
          this.addQuad();
          var angle, nFaces;
          nFaces = 10;
          var faceX, faceY, faceX2, faceY2, angle2;
          for (var i = 0; i < nFaces; i++) {
            angle = 2 * 3.1416 * i / nFaces;
            angle2 = 2 * 3.1416 * (i - 1) / nFaces;
            faceX = x + poteauW * Math.cos(angle);
            faceY = y + poteauW * Math.sin(angle);
            faceX2 = x + poteauW * Math.cos(angle2);
            faceY2 = y + poteauW * Math.sin(angle2);
            this.vertexPositions.push(faceX, 0, faceY, faceX, poteauH, faceY, faceX2, poteauH, faceY2, faceX2, 0, faceY2);
            this.pushTexture(2, 7);
            this.vertexNormals.push(Math.sin(angle), 0, Math.cos(angle), Math.sin(angle), 0, Math.cos(angle), Math.sin(angle), 0, Math.cos(angle), Math.sin(angle), 0, Math.cos(angle));
            this.addQuad();
          }
        }
        this.addQuad = function() {
          this.vertexIndices.push(this.nIndices, this.nIndices + 1, this.nIndices + 2, this.nIndices, this.nIndices + 2, this.nIndices + 3);
          this.nIndices += 4;
        }
        this.load = function() {
          this.createWalls();
          this.addPoteau(this.startX, this.startY, "start");
          this.addPoteau(this.endX, this.endY, "end");
        }
      }
      var Obj = function(texture, vertexPosition, vertexNormal, vertexTextureCoord, vertexIndex, render) {
        if (!vertexPosition) return;
        this.vertex = new Array();
        for (var i = 0; i < vertexPosition.length / 3; i++) {
          this.vertex.push(vertexPosition[i * 3], vertexPosition[i * 3 + 1], vertexPosition[i * 3 + 2], vertexNormal[i * 3], vertexNormal[i * 3 + 1], vertexNormal[i * 3 + 2], vertexTextureCoord[i * 2], vertexTextureCoord[i * 2 + 1]);
        }
        this.loaded = false;
        this.render = render;
        this.vertexIndex = vertexIndex;
        this.texture = GL.createTexture();
        this.texture.image = new Image();
        this.texture.image.src = texture;
        this.texture.image.parent = this;
        this.texture.image.onload = function() {
          lib_textures_loadTextureLR(this.parent.texture);
          this.loaded = true;
        }
        this.draw = function() {
          GL.uniform1i(SHADER_PROGRAM.render, this.render);
          GL.bindBuffer(GL.ARRAY_BUFFER, this.vertexBuffer);
          GL.vertexAttribPointer(SHADER_PROGRAM.vertexPositionAttribute, 3, GL.FLOAT, false, 32, 0);
          GL.vertexAttribPointer(SHADER_PROGRAM.vertexNormalAttribute, 3, GL.FLOAT, false, 32, 12);
          GL.vertexAttribPointer(SHADER_PROGRAM.textureCoordAttribute, 2, GL.FLOAT, false, 32, 24);
          GL.bindTexture(GL.TEXTURE_2D, this.texture);
          GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
          GL.drawElements(GL.TRIANGLES, this.vertexIndexBuffer.numItems, GL.UNSIGNED_SHORT, 0);
        }
        this.load = function() {
          this.vertexBuffer = GL.createBuffer();
          GL.bindBuffer(GL.ARRAY_BUFFER, this.vertexBuffer);
          GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(this.vertex), GL.STATIC_DRAW);
          this.vertexBuffer.numItems = this.vertex.length / 3;
          this.vertexIndexBuffer = GL.createBuffer();
          GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
          GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.vertexIndex), GL.STATIC_DRAW);
          this.vertexIndexBuffer.numItems = this.vertexIndex.length;
        }
      }
      var Background = function(R, x, y) {
        this.R = R;
        this.xCentre = x;
        this.yCentre = y;
        this.vertexPositions = new Array();
        this.vertexNormals = new Array();
        this.vertexTextureCoords = new Array();
        this.vertexIndices = new Array();
        this.nIndices = 0;
        var bandes = 20;
        var couronnes = 5;
        var xPoint, yPoint, zPoint, rCouronne;
        var theta, phi, theta2;
        for (var i = 0; i <= couronnes; i++) {
          phi = 0.5 * Math.PI * i / couronnes;
          rCouronne = this.R * Math.cos(phi);
          zPoint = this.R * Math.sin(phi);
          for (var j = 0; j < bandes; j++) {
            theta = 2 * Math.PI * j / bandes;
            theta2 = 2 * Math.PI * j / (bandes - 1);
            xPoint = this.xCentre + rCouronne * Math.cos(theta2);
            yPoint = this.yCentre + rCouronne * Math.sin(theta2);
            this.vertexPositions.push(xPoint, zPoint, yPoint);
            this.vertexNormals.push(Math.sin(theta2), 0, Math.sin(theta2));
            this.vertexTextureCoords.push(theta2 / (2 * Math.PI), phi / (Math.PI / 2));
            if (i != 0) {
              if (j != 0) this.vertexIndices.push(this.nIndices - 1, this.nIndices, this.nIndices - bandes);
              if (j != bandes - 1) this.vertexIndices.push(this.nIndices, this.nIndices - bandes, this.nIndices - bandes + 1);
            }
            this.nIndices++;
          }
        }
      }
      
      function lib_textures_loadTextureLR(texture) {
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, true);
        GL.bindTexture(GL.TEXTURE_2D, texture);
        GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, texture.image);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR_MIPMAP_NEAREST);
        GL.generateMipmap(GL.TEXTURE_2D);
      }
      var MV_MATRIX, MV_MATRIX_STACK = [];
      function lib_matrix_mvPushMatrix() {
        MV_MATRIX_STACK.push(MV_MATRIX.dup());
      }
      function lib_matrix_mvPopMatrix() {
        MV_MATRIX = MV_MATRIX_STACK.pop();
        return MV_MATRIX;
      }
      function lib_matrix_loadIdentity() {
        MV_MATRIX = Matrix.I(4);
      }
      function lib_matrix_multMatrix(m) {
        MV_MATRIX = MV_MATRIX.multiplyFast(m);
      }
      function lib_matrix_mvTranslate(v) {
        MV_MATRIX.translateFast(v[0], v[1], v[2]);
      }
      function lib_matrix_mvRotate(ang, v) {
        MV_MATRIX.rotateFast(Matrix.Rotation(ang, $V([v[0], v[1], v[2]])).ensure4x4());
      }
      function lib_matrix_mvRotateYFast(ang) {
        MV_MATRIX.rotateFast(Matrix.RotationXFast(ang));
      }
      function lib_matrix_mvRotateXFast(ang) {
        MV_MATRIX.rotateFast(Matrix.RotationYFast(ang));
      }
      function lib_matrix_mvRotateZFast(ang) {
        MV_MATRIX.rotateFast(Matrix.RotationZFast(ang));
      }
      function lib_matrix_perspective(fovy, aspect, znear, zfar) {
        var P_MATRIX = makePerspective(fovy, aspect, znear, zfar);
        GL.uniformMatrix4fv(SHADER_PROGRAM.pMatrixUniform, false, P_MATRIX.flattenFast());
      }
      function lib_matrix_setMatrixUniforms() {
        GL.uniformMatrix4fv(SHADER_PROGRAM.mvMatrixUniform, false, MV_MATRIX.flattenFast());
        GL.uniformMatrix3fv(SHADER_PROGRAM.nMatrixUniform, false, MV_MATRIX.inverse().flattenTransposeFast3());
      }
    </script>
    
  </head>
  <body style="margin: 0px">
    <canvas id="canvas" style="border: none; cursor: crosshair;"></canvas>
    <center>
      <canvas id="mycanvas" width="920" height="600" style="border: none; cursor: crosshair;"></canvas>
    </center>
    <div id="image">
      <img id="cake" src="img/cake.png" onload="finishLoading(1)" />
      <img id="candle1" src="img/candle1.png" onload="finishLoading(2)" />
      <img id="candle2" src="img/candle2.png" onload="finishLoading(4)" />
      <img id="square" src="img/square.png" onload="finishLoading(8)" />
    </div>
    <div id='info' class="container">
      <div class="jumbotron">
        <div class="panel panel-info">
          <div class="panel-heading">
            <h3>Error</h3>
          </div>
          <div class="panel-body">
            <p>Sorry, your browser does not support this feature</p>
          </div>
        </div>
      </div>
    </div>
    <div id='info0' class="container">
      <div class="jumbotron">
        <div class="panel panel-info">
          <div class="panel-heading">
            <h3>Maze</h3>
          </div>
          <div class="panel-body">
            <p>Please walk from the beginning of the maze to the end</p>
            <p> Control: Mouse, Up, Down, Left, Right, Space, or Right Mouse for Jump</p>
          </div>
        </div>
      </div>
    </div>
    <div id='info1' class="container">
      <div class="jumbotron">
        <div class="panel panel-info">
          <div class="panel-heading">
            <h3>First round</h3>
          </div>
          <div class="panel-body">
            <p>Congratulations on your passing the test level, the game officially begins!</p>
            <h6>Please walk from the beginning of the maze to the end</h6>
            <h6> Control: Mouse, Up, Down, Left, Right, Space, or Right Mouse for Jump</h6>
          </div>
        </div>
      </div>
    </div>
    <div id='info2' class="container">
      <div class="jumbotron">
        <div class="panel panel-info">
          <div class="panel-heading">
            <h3>The second level</h3>
          </div>
          <div class="panel-body">
            <p>Please continue the game!</p>
            <h6>Please walk from the beginning of the maze to the end</h6>
            <h6>Control: Mouse, Up, Down, Left, Right, Space, or Right Mouse for Jump</h6>
          </div>
        </div>
      </div>
    </div>
    <div id='info3' class="container">
      <div class="jumbotron">
        <div class="panel panel-info">
          <div class="panel-heading">
            <h3>The third level</h3>
          </div>
          <div class="panel-body">
            <p>Please ask 3 wishes first, then blow out all the candles</p>
            <h6>Control: mouse</h6>
          </div>
        </div>
      </div>
    </div>
    <div id='info4' class="container">
      <div class="jumbotron">
        <div class="panel panel-info">
          <div class="panel-heading">
            <h3>Happy Birthday</h3>
          </div>
          <div class="panel-body">
            <p>Are you happy? </p>
            <p>You are happy and I am happy. </p>
            <p>Look at you and laugh, I want to laugh. </p>
            <p>Recalling the defibrillator's posture when you were playing, letting my mouth feel like honey, from dark to dawn. </p>
            <p>There is also an imitation of the Northeast in your day, although I can't learn from dropping out. </p>
            <p>Look at the art photos of your dancing, I thought, if I could have the butterfly beside you. </p>
            <p>I hope you can tolerate the thoughts that I have left beside you every day. Is it sometimes annoying? </p>
            <p>When you grow up a year old, may you become more mature and beautiful. </p>
            <p>The internship and research performance is smooth! </p>
            <p>Please forgive my stupid tongue, and scratch my head to think of it. There are so many. </p>
            <h6>MAY 29, 2018</h6>
          </div>
        </div>
      </div>
    </div>
    <center><div id='startButton'></div></center>
    <audio id='bgmusic' src='music/SeasonsofLove.mp3' preload loop></audio>
    <audio id='birthmusic' src='music/Birthday.mp3' preload loop></audio>
  </body>
</html>
